{"ast":null,"code":"import { useContext, useRef, useCallback, useMemo, useEffect } from 'react';\nimport warning from 'warning';\nimport { debounce } from '../utils/debounce.js';\nimport { AriaAnnouncerContext } from './AriaAnnouncerContext.js';\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nconst useAriaAnnouncer = function () {\n  let {\n    debounce: debounceInterval = 0\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const context = useContext(AriaAnnouncerContext);\n  const mountedRef = useRef(true);\n  const baseAnnounce = useCallback((announcement, delay) => {\n    const isReactAnnouncerInstalled = context && context.announce;\n    warning(isReactAnnouncerInstalled, \"useAriaAnnouncer is being used without an AriaAnnouncerProvider. Your application should be wrapped in an AriaAnnouncerProvider\");\n\n    function makeAnnouncement() {\n      if (mountedRef.current) {\n        if (isReactAnnouncerInstalled) {\n          context.announce(announcement);\n        }\n      }\n    }\n\n    if (delay) {\n      setTimeout(makeAnnouncement, delay);\n    } else {\n      makeAnnouncement();\n    }\n  }, [context]);\n  const announce = useMemo(() => debounceInterval > 0 ? debounce(baseAnnounce, debounceInterval) : baseAnnounce, [baseAnnounce, debounceInterval]);\n  const ariaAnnouncer = useMemo(() => __spreadProps(__spreadValues({}, context), {\n    announce\n  }), [context, announce]);\n  useEffect(() => () => {\n    mountedRef.current = false;\n  }, []);\n  return ariaAnnouncer;\n};\n\nexport { useAriaAnnouncer };","map":{"version":3,"mappings":";;;;AAAA,IAASA,kBAAaC,eAAtB;AACA,IAAOC,UAAO,GAAMC,uBAApB;AACA,IAASC,iBAAgB,mCAAzB;AACA,IAAwBC,4BAA4B,sBAApD;AASA,gBAAaC,oBACHC,cADV;AAGE,mBAAgBN,iBAAWI,oBAA3B;;AACA,sBAAmBG,WAAOC,KAAPD,KAAaE;EAAAC;EAAAC;EAAAC;EAAAJ;AAAA,qBAAhC;;IACAK,cAAMC,IAAYC,CAAZD,EAAef,CAAfe,KAA0B;EAE5B,gCAEAb,gBACEe,KADFf,CACEe,CADFf,EACEe,IADFf,GAKAgB,2BAAyBC,IAAzB;;2BAEI,yCAA6B;oBACyC,gBACpEC,mBAAOD,IAAPC,EAASC,OAATD;EACD;EACF;AACF;;AAED,iBAAS,GAAE,6CAAX;;AAMF;EAAA;IAAAhB;EAAA;QAACgB,OAAO;EAAC,MACTE,yBADS;EAGX,kBAAiBC,8BAEMC,KAFND,KAGTnB;IACY,MAClBa,uDADkB;WACL;;aAAkBQ;MAChC,IAACH,kBAAD,EAAC;QAEF,IAAmBL,yBAAnB,EACS;UACLG,OAAU,SAAV,CAAUM,YAAV;;;IAGF;;QAACN,OAAO;gBAAU;IAAC,OACnB;MAEOK,gBACK;IACVH;EACD,CAnBcC,EAmBd,SAnBcA,CAAjB;EAwBA;;;;;;;;CA3BE","names":["useCallback","useContext","warning","Object","debounce","AriaAnnouncerContext","useAriaAnnouncer","hasOwnProperty","useRef","value","key","enumerable","configurable","writable","__spreadValues","baseAnnounce","a","isReactAnnouncerInstalled","__defNormalProp","prop","context","announce","mountedRef","useMemo","delay","makeAnnouncement","announcement"],"sources":["/Users/forgi/Development/code/phase-5/lux_nyc_final_project/lux_nyc_react_frontend/node_modules/@jpmorganchase/uitk-core/dist-es/packages/core/src/src/aria-announcer/useAriaAnnouncer.ts"],"sourcesContent":["import { useCallback, useContext, useEffect, useMemo, useRef } from \"react\";\nimport warning from \"warning\";\nimport { debounce } from \"../utils/debounce\";\nimport { AriaAnnouncer, AriaAnnouncerContext } from \"./AriaAnnouncerContext\";\n\nexport type useAnnouncerOptions = {\n  debounce?: number;\n};\nexport type useAriaAnnouncerHook = (\n  options?: useAnnouncerOptions\n) => AriaAnnouncer;\n\nexport const useAriaAnnouncer: useAriaAnnouncerHook = ({\n  debounce: debounceInterval = 0,\n} = {}) => {\n  const context = useContext(AriaAnnouncerContext);\n  const mountedRef = useRef(true);\n  const baseAnnounce = useCallback(\n    (announcement, delay) => {\n      const isReactAnnouncerInstalled = context && context.announce;\n\n      warning(\n        isReactAnnouncerInstalled,\n        \"useAriaAnnouncer is being used without an AriaAnnouncerProvider. Your application should be wrapped in an AriaAnnouncerProvider\"\n      );\n\n      function makeAnnouncement() {\n        if (mountedRef.current) {\n          if (isReactAnnouncerInstalled) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            context!.announce(announcement);\n          }\n        }\n      }\n\n      if (delay) {\n        setTimeout(makeAnnouncement, delay);\n      } else {\n        makeAnnouncement();\n      }\n    },\n    [context]\n  );\n\n  const announce = useMemo(\n    () =>\n      debounceInterval > 0\n        ? debounce(baseAnnounce, debounceInterval)\n        : baseAnnounce,\n    [baseAnnounce, debounceInterval]\n  );\n\n  const ariaAnnouncer = useMemo(\n    () => ({\n      ...context,\n      announce,\n    }),\n    [context, announce]\n  );\n\n  useEffect(\n    () => () => {\n      mountedRef.current = false;\n    },\n    []\n  );\n\n  return ariaAnnouncer;\n};\n"]},"metadata":{},"sourceType":"module"}