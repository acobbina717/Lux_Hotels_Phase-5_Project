{"ast":null,"code":"import { jsxs, jsx } from 'react/jsx-runtime';\nimport cx from 'classnames';\nimport { forwardRef, useState, useRef } from 'react';\nimport '../form-field-context/FormFieldContext.js';\nimport { useFormFieldProps } from '../form-field-context/useFormFieldProps.js';\nimport { makePrefixer } from '../utils/makePrefixer.js';\nimport { useControlled } from '../utils/useControlled.js';\nimport { useForkRef } from '../utils/useForkRef.js';\nimport '../aria-announcer/AriaAnnouncerContext.js';\nimport 'warning';\nimport '../theme/Theme.js';\nimport { useCursorOnFocus } from './useCursorOnFocus.js';\nimport './Input.css.js';\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nvar __objRest = (source, exclude) => {\n  var target = {};\n\n  for (var prop in source) if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];\n\n  if (source != null && __getOwnPropSymbols) for (var prop of __getOwnPropSymbols(source)) {\n    if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop)) target[prop] = source[prop];\n  }\n  return target;\n};\n\nconst withBaseName = makePrefixer(\"uitkInput\");\n\nfunction mergeA11yProps() {\n  let a11yProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let inputProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const ariaLabelledBy = cx(a11yProps[\"aria-labelledby\"], inputProps[\"aria-labelledby\"]);\n  return __spreadProps(__spreadValues(__spreadValues({}, a11yProps), inputProps), {\n    \"aria-labelledby\": ariaLabelledBy ? Array.from(new Set(ariaLabelledBy.split(\" \"))).join(\" \") : null\n  });\n}\n\nconst Input = /* @__PURE__ */forwardRef(function Input2(_a, ref) {\n  var _b = _a,\n      {\n    className: classNameProp,\n    cursorPositionOnFocus,\n    disabled,\n    emptyReadOnlyMarker = \"\\u2014\",\n    endAdornment,\n    highlightOnFocus,\n    id,\n    inputComponent: InputComponent = \"input\",\n    inputProps: inputPropsProp,\n    style,\n    value: valueProp,\n    defaultValue: defaultValueProp = valueProp === void 0 ? \"\" : void 0,\n    onBlur,\n    onChange,\n    onFocus,\n    onKeyDown,\n    onKeyUp,\n    onMouseUp,\n    onMouseMove,\n    onMouseDown,\n    readOnly: readOnlyProp,\n    renderSuffix,\n    startAdornment,\n    textAlign = \"left\",\n    type = \"text\"\n  } = _b,\n      other = __objRest(_b, [\"className\", \"cursorPositionOnFocus\", \"disabled\", \"emptyReadOnlyMarker\", \"endAdornment\", \"highlightOnFocus\", \"id\", \"inputComponent\", \"inputProps\", \"style\", \"value\", \"defaultValue\", \"onBlur\", \"onChange\", \"onFocus\", \"onKeyDown\", \"onKeyUp\", \"onMouseUp\", \"onMouseMove\", \"onMouseDown\", \"readOnly\", \"renderSuffix\", \"startAdornment\", \"textAlign\", \"type\"]);\n\n  const _a2 = useFormFieldProps(),\n        {\n    a11yProps: _b2 = {}\n  } = _a2,\n        _c = _b2,\n        {\n    readOnly: a11yReadOnly,\n    disabled: a11yDisabled\n  } = _c,\n        restA11y = __objRest(_c, [\"readOnly\", \"disabled\"]),\n        {\n    setFocused: setFormFieldFocused,\n    inFormField\n  } = _a2;\n\n  const [focused, setFocused] = useState(false);\n  const inputRef = useRef(null);\n  const handleRef = useForkRef(inputRef, ref);\n  const cursorOnFocusHelpers = useCursorOnFocus(inputRef, {\n    cursorPositionOnFocus,\n    highlightOnFocus\n  });\n  const isDisabled = disabled || a11yDisabled;\n  const isReadOnly = readOnlyProp || a11yReadOnly;\n  const inputProps = mergeA11yProps(restA11y, inputPropsProp);\n  const isEmptyReadOnly = isReadOnly && !defaultValueProp && !valueProp;\n  const defaultValue = isEmptyReadOnly ? emptyReadOnlyMarker : defaultValueProp;\n  const [value1, setValue] = useControlled({\n    controlled: valueProp,\n    default: defaultValue,\n    name: \"Input\",\n    state: \"value\"\n  });\n\n  const handleChange = event => {\n    const value = event.target.value;\n    setValue(value);\n    onChange == null ? void 0 : onChange(event, value);\n  };\n\n  const handleFocus = event => {\n    onFocus == null ? void 0 : onFocus(event);\n    setFormFieldFocused == null ? void 0 : setFormFieldFocused(true);\n    setFocused(true);\n  };\n\n  const handleBlur = event => {\n    onBlur == null ? void 0 : onBlur(event);\n    setFormFieldFocused == null ? void 0 : setFormFieldFocused(false);\n    setFocused(false);\n  };\n\n  const handleMouseMove = event => {\n    cursorOnFocusHelpers.handleMouseMove(event);\n    onMouseMove == null ? void 0 : onMouseMove(event);\n  };\n\n  const handleMouseUp = event => {\n    cursorOnFocusHelpers.handleMouseUp();\n    onMouseUp == null ? void 0 : onMouseUp(event);\n  };\n\n  const handleMouseDown = event => {\n    cursorOnFocusHelpers.handleMouseDown();\n    onMouseDown == null ? void 0 : onMouseDown(event);\n  };\n\n  return /* @__PURE__ */jsxs(\"div\", __spreadProps(__spreadValues({\n    className: cx(withBaseName(), {\n      [withBaseName(`${textAlign}TextAlign`)]: textAlign,\n      [withBaseName(\"formField\")]: inFormField,\n      [withBaseName(\"focused\")]: focused && !inFormField,\n      [withBaseName(\"disabled\")]: isDisabled,\n      [withBaseName(\"inputAdornedStart\")]: startAdornment,\n      [withBaseName(\"inputAdornedEnd\")]: endAdornment\n    }, classNameProp),\n    style\n  }, other), {\n    children: [startAdornment && /* @__PURE__ */jsx(\"div\", {\n      className: withBaseName(\"prefixContainer\"),\n      children: startAdornment\n    }), /* @__PURE__ */jsx(InputComponent, __spreadProps(__spreadValues({\n      type,\n      id\n    }, inputProps), {\n      className: cx(withBaseName(\"input\"), inputProps == null ? void 0 : inputProps.className),\n      disabled: isDisabled,\n      ref: handleRef,\n      value: value1,\n      onBlur: handleBlur,\n      onChange: handleChange,\n      onKeyDown,\n      onKeyUp,\n      onFocus: handleFocus,\n      onMouseDown: handleMouseDown,\n      onMouseUp: handleMouseUp,\n      onMouseMove: handleMouseMove,\n      readOnly: isReadOnly\n    })), endAdornment && /* @__PURE__ */jsx(\"div\", {\n      className: withBaseName(\"suffixContainer\"),\n      children: endAdornment\n    }), renderSuffix == null ? void 0 : renderSuffix({\n      disabled,\n      focused\n    })]\n  }));\n});\nexport { Input };","map":{"version":3,"mappings":";;;;;;;;;;;;;AAAA;AAAA,IAAOA,UAAQ,0BAAf;AACA,qBAYEC,SACQ,0BAbV;AAeA,IAASC,sBAAiBC,MAAQ,sBAAlC;AACA,yBAAuBC,UAAvB,CAAoCC,cAApC;AACA,IAASC,qBAAgB,CAAQC,SAAxBD,CAAwBE,oBAAjC;;AAEA,sBAAqB;EAAAC;EAAAC;EAAAC;EAAAC;AAAA,qBAArB;;AAEA,kBAAkB,GAAGC;EAgFZC,uBAC8DC,MAD9DD,GAIP,gBAAoB,KAApB,CAAoBC,CAApB,EAAyBC,IAAzB,GAKOC;;EACL,yBACA,SAAaD,IAAb,IAAaE,sBAAb,EAAa;QACsCC,4BACnDF,eAAiB,IAAEG,IAAF,EAAgBL,OAAhB,CAAjB;EAGD;EACF;AAEM,CAnGP;;AAiHI,IAA4DM,6DAA5D;;AACAC,aAAcC,wBAAmBC;EAkBnC,UACEC,KADF;;OAUM,IAACC,QAAOC,QACd,gBAAiB1B,KAAjB,CAAiBA,MAAjB,EAA8Be,IAA9B,KAA8BY,yBAA9B,EACMC,qBAAsB,MAAtBA;;EACN,UAA0B,QAA1B,IAA0BX,mBAA1B,OACuB;QACLU,8DACfE;EAEH;EACA;CArCER;;AA+CD,MAACS,YAAC,4BAAF;;AAED,0BAA+D;EAAA,IAA7CN,SAA6C;EAAA;EAC7D,oBAAcO,KAAK,CAACF,4BAAD,EAAcG,6BAAd,CAAnB;SACQZ,aAAM,CAACa,cAAC,2CAAF,EAAE;IAChBC,mBAAWH,cAAc;EADT,CAAF;AAIhB;;AACS,WAAGA,kBAAOI;QACjBC,GAAmBC;MAAA;aACT,eADS;yBAAA;IAIrBC,QAJqB;uBAKJ,GAAC,QALG;gBAAA;oBAAA;MAAA;IAUrBC,cAAqB,gBAAuC,GAAK,OAV5C;IAWnBC,0BAXmB;SAAA;SAcnB,WAdmB;IAgBrBnB,YAAmB,kBAA4C,qCAhB1C;UAAA;YAAA;WAAA;IAsBrBoB,SAtBqB;WAAA;aAAA;eAAA;IA4BrBC,WA5BqB;IA8BjBC,sBA9BiB;gBAAA;IAkCbC,cAlCa;aAmCZd,SAnCY;IAoCbe;EApCa,IAqCbC;MAAAC,iBAAc,MACd,WADc,EAEf,uBAFe,EAKlBC,UALkB,EAMjB,qBANiB,sCASXL,IATW,kCAWlB,OAXkB,EAYhBE,OAZgB,EAahBI,cAbgB,EAcf,QAde,cAgBhBX,SAhBgB,EAiBhBY,WAjBgB,EAkBhBvC,SAlBgB,EAmBhBwC,WAnBgB,EAoBhBjB,aApBgB,EAqBhBO,aArBgB,EAsBhBW,UAtBgB,EAuBhBC,cAvBgB,EAwBhBX,gBAxBgB,EAyBhBY,WAzBgB,EA0BhBC,MA1BgB;;EA4BhB;EAAA;IAAA/B;EAAA;EAAA;EAAA;IAAAgC;IAAAlB;EAAA;EAAA;EAAA;IAAAmB;IAAAC;EAAA;;kBACWD;EACNd,uBAAS,CAAEb,IAAF,CAATa;8BAAyD;4BAC/D;IAEAgB,qBAFA;;EAAA;EAEoC;;QAEvC3B;EACF,MAAC4B,+DAAD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA1EmB,CAAV","names":["cx","useRef","useFormFieldProps","Object","useControlled","hasOwnProperty","useCursorOnFocus","prototype","propertyIsEnumerable","enumerable","configurable","writable","value","makePrefixer","mergeA11yProps","b","prop","__defNormalProp","__getOwnPropSymbols","__propIsEnum","ariaLabelledBy","__spreadProps","defaultValue","defaultValueProp","valueProp","a11yProps","focused","source","exclude","handleRef","target","withBaseName","event","inputProps","__spreadValues","onChange","forwardRef","setFormFieldFocused","_a","disabled","inputComponent","cursorOnFocusHelpers","onKeyDown","onMouseDown","className","startAdornment","type","_b","other","style","id","ref","onBlur","onKeyUp","onFocus","onMouseUp","onMouseMove","readOnly","setFocused","inFormField","renderSuffix","isEmptyReadOnly"],"sources":["/Users/forgi/Development/code/phase-5/lux_nyc_final_project/lux_nyc_react_frontend/node_modules/@jpmorganchase/uitk-core/dist-es/packages/core/src/src/input/Input.tsx"],"sourcesContent":["import cx from \"classnames\";\nimport {\n  ChangeEvent,\n  ElementType,\n  FocusEvent,\n  FocusEventHandler,\n  forwardRef,\n  HTMLAttributes,\n  InputHTMLAttributes,\n  KeyboardEventHandler,\n  MouseEvent,\n  MouseEventHandler,\n  ReactNode,\n  useRef,\n  useState,\n} from \"react\";\nimport { useFormFieldProps } from \"../form-field-context\";\nimport { makePrefixer, useControlled, useForkRef } from \"../utils\";\nimport { useCursorOnFocus } from \"./useCursorOnFocus\";\n\nimport \"./Input.css\";\n\nconst withBaseName = makePrefixer(\"uitkInput\");\n\n// TODO: Double confirm whether this should be extending DivElement given root is `<div>`.\n// And forwarded ref is not assigned to the root like other components.\nexport interface InputProps\n  extends Omit<HTMLAttributes<HTMLDivElement>, \"onChange\" | \"defaultValue\"> {\n  /**\n   * Determines the position of the text cursor on focus of the input.\n   *\n   * start = place cursor at the beginning<br>\n   * end = place cursor at the end<br>\n   * \\# = index to place the cursor<br>\n   */\n  cursorPositionOnFocus?: \"start\" | \"end\" | number;\n  /**\n   * The value of the `input` element, required for an uncontrolled component.\n   */\n  defaultValue?: HTMLInputElement[\"defaultValue\"];\n  /**\n   * If `true`, the component is disabled.\n   */\n  disabled?: HTMLInputElement[\"disabled\"];\n  /**\n   * The marker to use in an empty read only Input.\n   * Use `''` to disable this feature. Defaults to '—'.\n   */\n  emptyReadOnlyMarker?: string;\n  /**\n   * Determines what gets highlighted on focus of the input.\n   *\n   * If `true` all text will be highlighted.\n   * If an array text between those indices will be highlighted\n   * e.g. [0,1] will highlight the first character.\n   */\n  highlightOnFocus?: boolean | number[];\n  /**\n   * The HTML element to render the Input, e.g. 'input', a custom React component.\n   */\n  inputComponent?: ElementType;\n  /**\n   * [Attributes](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#Attributes) applied to the `input` element.\n   */\n  inputProps?: InputHTMLAttributes<HTMLInputElement>;\n  onBlur?: FocusEventHandler<HTMLInputElement>;\n  /**\n   * Callback for change event.\n   */\n  onChange?: (event: ChangeEvent<HTMLInputElement>, value: string) => void;\n  onFocus?: FocusEventHandler<HTMLInputElement>;\n  onKeyDown?: KeyboardEventHandler<HTMLInputElement>;\n  onKeyUp?: KeyboardEventHandler<HTMLInputElement>;\n  onMouseUp?: MouseEventHandler<HTMLInputElement>;\n  onMouseMove?: MouseEventHandler<HTMLInputElement>;\n  onMouseDown?: MouseEventHandler<HTMLInputElement>;\n  /**\n   * If `true`, the component is read only.\n   */\n  readOnly?: boolean;\n  /**\n   *\n   * Determines the alignment of the input text.\n   */\n  textAlign?: \"left\" | \"right\" | \"center\";\n  type?: HTMLInputElement[\"type\"];\n  /**\n   * The value of the `input` element, required for a controlled component.\n   */\n  value?: HTMLInputElement[\"value\"];\n  renderSuffix?: (state: {\n    disabled?: boolean;\n    error?: boolean;\n    focused?: boolean;\n    margin?: \"dense\" | \"none\" | \"normal\";\n    required?: boolean;\n    startAdornment?: ReactNode;\n  }) => ReactNode;\n  endAdornment?: ReactNode;\n  startAdornment?: ReactNode;\n}\n\nfunction mergeA11yProps(\n  a11yProps: Partial<ReturnType<typeof useFormFieldProps>[\"a11yProps\"]> = {},\n  inputProps: InputProps[\"inputProps\"] = {}\n) {\n  const ariaLabelledBy = cx(\n    a11yProps[\"aria-labelledby\"],\n    inputProps[\"aria-labelledby\"]\n  );\n\n  return {\n    ...a11yProps,\n    ...inputProps,\n    // THe weird filtering is due to TokenizedInputBase\n    \"aria-labelledby\": ariaLabelledBy\n      ? Array.from(new Set(ariaLabelledBy.split(\" \"))).join(\" \")\n      : null,\n  };\n}\n\nexport const Input = forwardRef<HTMLInputElement, InputProps>(function Input(\n  {\n    className: classNameProp,\n    cursorPositionOnFocus,\n    disabled,\n    emptyReadOnlyMarker = \"—\",\n    endAdornment,\n    highlightOnFocus,\n    id,\n    inputComponent: InputComponent = \"input\",\n    inputProps: inputPropsProp,\n    style,\n    value: valueProp,\n    // If we leave both value and defaultValue undefined, we will get a React warning on first edit\n    // (uncontrolled to controlled warning) from the React input\n    defaultValue: defaultValueProp = valueProp === undefined ? \"\" : undefined,\n    onBlur,\n    onChange,\n    onFocus,\n    onKeyDown,\n    onKeyUp,\n    onMouseUp,\n    onMouseMove,\n    onMouseDown,\n    readOnly: readOnlyProp,\n    renderSuffix,\n    startAdornment,\n    textAlign = \"left\",\n    type = \"text\",\n    ...other\n  },\n  ref\n) {\n  const {\n    a11yProps: {\n      readOnly: a11yReadOnly,\n      disabled: a11yDisabled,\n      ...restA11y\n    } = {},\n    setFocused: setFormFieldFocused,\n    inFormField,\n  } = useFormFieldProps();\n\n  const [focused, setFocused] = useState(false);\n  const inputRef = useRef(null);\n  const handleRef = useForkRef(inputRef, ref);\n  const cursorOnFocusHelpers = useCursorOnFocus(inputRef, {\n    cursorPositionOnFocus,\n    highlightOnFocus,\n  });\n\n  const isDisabled = disabled || a11yDisabled;\n  const isReadOnly = readOnlyProp || a11yReadOnly;\n  const inputProps = mergeA11yProps(restA11y, inputPropsProp);\n  const isEmptyReadOnly = isReadOnly && !defaultValueProp && !valueProp;\n  const defaultValue = isEmptyReadOnly ? emptyReadOnlyMarker : defaultValueProp;\n\n  const [value, setValue] = useControlled({\n    controlled: valueProp,\n    default: defaultValue,\n    name: \"Input\",\n    state: \"value\",\n  });\n\n  const handleChange = (event: ChangeEvent<HTMLInputElement>) => {\n    const value = event.target.value;\n    setValue(value);\n    onChange?.(event, value);\n  };\n\n  const handleFocus = (event: FocusEvent<HTMLInputElement>) => {\n    onFocus?.(event);\n    setFormFieldFocused?.(true);\n    setFocused(true);\n  };\n\n  const handleBlur = (event: FocusEvent<HTMLInputElement>) => {\n    onBlur?.(event);\n    setFormFieldFocused?.(false);\n    setFocused(false);\n  };\n\n  const handleMouseMove = (event: MouseEvent<HTMLInputElement>) => {\n    cursorOnFocusHelpers.handleMouseMove(event);\n\n    onMouseMove?.(event);\n  };\n\n  const handleMouseUp = (event: MouseEvent<HTMLInputElement>) => {\n    cursorOnFocusHelpers.handleMouseUp();\n\n    onMouseUp?.(event);\n  };\n\n  const handleMouseDown = (event: MouseEvent<HTMLInputElement>) => {\n    cursorOnFocusHelpers.handleMouseDown();\n\n    onMouseDown?.(event);\n  };\n\n  return (\n    <div\n      className={cx(\n        withBaseName(),\n        {\n          [withBaseName(`${textAlign}TextAlign`)]: textAlign,\n          [withBaseName(\"formField\")]: inFormField,\n          [withBaseName(\"focused\")]: focused && !inFormField,\n          [withBaseName(\"disabled\")]: isDisabled,\n          [withBaseName(\"inputAdornedStart\")]: startAdornment,\n          [withBaseName(\"inputAdornedEnd\")]: endAdornment,\n        },\n        classNameProp\n      )}\n      style={style}\n      {...other}\n    >\n      {startAdornment && (\n        <div className={withBaseName(\"prefixContainer\")}>{startAdornment}</div>\n      )}\n      <InputComponent\n        type={type}\n        id={id}\n        {...inputProps}\n        className={cx(withBaseName(\"input\"), inputProps?.className)}\n        disabled={isDisabled}\n        ref={handleRef}\n        value={value}\n        onBlur={handleBlur}\n        onChange={handleChange}\n        onKeyDown={onKeyDown}\n        onKeyUp={onKeyUp}\n        onFocus={handleFocus}\n        onMouseDown={handleMouseDown}\n        onMouseUp={handleMouseUp}\n        onMouseMove={handleMouseMove}\n        readOnly={isReadOnly}\n      />\n      {endAdornment && (\n        <div className={withBaseName(\"suffixContainer\")}>{endAdornment}</div>\n      )}\n      {/* TODO: Confirm implementation of suffix */}\n      {renderSuffix?.({ disabled, focused })}\n    </div>\n  );\n});\n"]},"metadata":{},"sourceType":"module"}