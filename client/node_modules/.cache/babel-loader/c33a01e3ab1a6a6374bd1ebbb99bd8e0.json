{"ast":null,"code":"import { useFloatingUI } from '../popper/useFloatingUI.js';\nimport { arrow, offset, flip, shift, limitShift, useInteractions, useHover, safePolygon, useFocus, useRole, useDismiss } from '@floating-ui/react-dom-interactions';\nimport { useAriaAnnounce } from './useAriaAnnounce.js';\nimport { useRef, useCallback } from 'react';\nimport { margin } from '../utils/marginMiddleware.js';\nimport { useControlled } from '../utils/useControlled.js';\nimport 'react/jsx-runtime';\nimport 'classnames';\nimport '../aria-announcer/AriaAnnouncerContext.js';\nimport 'warning';\nimport '../theme/Theme.js';\nimport { isDesktop } from '../window/WindowContext.js';\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nfunction useTooltip(props) {\n  const {\n    enterDelay = 100,\n    leaveDelay = 0,\n    open: openProp,\n    onOpenChange,\n    placement: placementProp = \"right\",\n    disabled,\n    disableHoverListener,\n    disableFocusListener\n  } = props || {};\n  const arrowRef = useRef(null);\n  const [open1, setOpen] = useControlled({\n    controlled: openProp,\n    default: false,\n    name: \"Tooltip\",\n    state: \"open\"\n  });\n\n  const handleOpenChange = open => {\n    setOpen(open);\n    onOpenChange == null ? void 0 : onOpenChange(open);\n  };\n\n  const middleware = isDesktop ? [margin(8), arrow({\n    element: arrowRef\n  })] : [offset(8), flip(), shift({\n    limiter: limitShift({\n      offset: () => {\n        var _a, _b, _c, _d;\n\n        return Math.max((_b = (_a = arrowRef.current) == null ? void 0 : _a.offsetWidth) != null ? _b : 0, (_d = (_c = arrowRef.current) == null ? void 0 : _c.offsetHeight) != null ? _d : 0);\n      }\n    })\n  }), arrow({\n    element: arrowRef\n  })];\n  const {\n    floating,\n    reference,\n    x,\n    y,\n    strategy,\n    update,\n    middlewareData,\n    placement,\n    context\n  } = useFloatingUI({\n    open: open1,\n    onOpenChange: handleOpenChange,\n    placement: placementProp,\n    middleware\n  });\n  const handleArrowRef = useCallback(node => {\n    arrowRef.current = node;\n    update();\n  }, [update]);\n  const {\n    getReferenceProps,\n    getFloatingProps\n  } = useInteractions([useHover(context, {\n    delay: {\n      open: enterDelay,\n      close: leaveDelay\n    },\n    enabled: !disableHoverListener,\n    handleClose: isDesktop ? null : safePolygon()\n  }), useFocus(context, {\n    enabled: !disableFocusListener\n  }), useRole(context, {\n    role: \"tooltip\"\n  }), useDismiss(context, {\n    ancestorScroll: true\n  }), useAriaAnnounce(context, {\n    delay: {\n      open: enterDelay,\n      close: leaveDelay\n    }\n  })]);\n\n  const getTooltipProps = userProps => {\n    var _a, _b, _c, _d;\n\n    const arrowProps = {\n      ref: handleArrowRef,\n      style: {\n        left: (_b = (_a = middlewareData.arrow) == null ? void 0 : _a.x) != null ? _b : \"\",\n        top: (_d = (_c = middlewareData.arrow) == null ? void 0 : _c.y) != null ? _d : \"\"\n      }\n    };\n    return __spreadValues({\n      arrowProps,\n      open: open1\n    }, getFloatingProps(__spreadProps(__spreadValues({\n      \"data-placement\": placement\n    }, userProps), {\n      ref: floating,\n      style: __spreadValues({\n        top: y != null ? y : \"\",\n        left: x != null ? x : \"\",\n        position: strategy\n      }, (userProps == null ? void 0 : userProps.style) || {})\n    })));\n  };\n\n  const getTriggerProps = userProps => {\n    return getReferenceProps(__spreadProps(__spreadValues({}, userProps), {\n      ref: reference\n    }));\n  };\n\n  if (disabled) {\n    return {\n      getTooltipProps: args => args,\n      getTriggerProps: args => args\n    };\n  }\n\n  return {\n    getTooltipProps,\n    getTriggerProps\n  };\n}\n\nexport { useTooltip };","map":{"version":3,"mappings":";;;;;;;;;;;;AAAA,IAASA,kBAAa,CAA4BC,cAAlD;AACA,IACEC,UAAK,GACDC,uBAFN;AAaA,IAASC,oBAAeD,MAAQ,0BAAhC;AACA,uBAA8B,+BAA9B;AACA,gBAIa,SACL,UADK,CAENE,cANP;AAQA,IAASC,eAAiBH,qCAA1B;;AA2BA,mBAAgBI,SAAWC,GAAXD,EAAoCE,KAApCF,KAAoCG;EAAAC;EAAAC;EAAAC;EAAAJ;AAAA,qBAApD;;AACE,kBACY,OAAMK,CAAN,KACA;EASZ,iBAAiBC,UAA8B,EAA9BA,CAAjB,EAEA,sBAAqBD,CAArB,EAAwBE,IAAxB,GACEC,eAAoB,kBAApBA;;EACAC,yBACAC,iBAAeC,sBAAfD,EAAe;IACfE,gBAAa,KAAbA,CAAaP,CAAbO,EAAaC,IAAbD,GACCE;EACH;SACSC;CApBT;;iBAsBE;;SAKYjB,WAACC;EACTiB;IAAAA,UAAM,MAANA;IAAMC,cAAND;IAAME,cAANF;IAAMG,YAANH;IAAMI,kCAANJ;IAAMK,QAANL;IAAMM,oBAANN;IAAMO;EAANP,IAAMjB,WAANiB;EACAQ,cAAM,eAANA;gBACSC,wBAAa;gBAClBC,QADkB;aAMnB,KANmB;UAOpB,SAPoB;IAQtBjC;EARsB;;wBAQM;WAC5B;IACN0B,YACEQ,IAAQ,IADV,GAEW,MAFX,GAGGR,YAEO,MALV;EAWED;;EACAC,4BAA8B,IAC9BC,SAD8B,OAEpB;IACVQ,OAAC;EADS,EAFoB,IAO5BC,CACAC,SADAD,MAGF,EAHEA,OAGK;IACRE,OAAC;MAEIL;QACI,gBAAUM,EAAV;;QACNC,OAAKC,IAAE,IAAF,CAAE,iFAAF,EAAE,kFAAF,CAALD;MACEf;IALJ;EADO,EAHLW;IAaAM;IAbAN,CAPFV;;;IAsB2BiB;IAAuBC;IAAAC;IAAAC;IAAAT;IAAAU;IAAApB;IAAAqB;MAAAlD;UAAGmD,KAAH;gBAC1CD,kBAD0C;IAC/BE,wBAD+B;;EAAA;EAE5BC,kCAAoB;YAAG;UAC9B;EACbX,CAFwC,EAExCA,CACEf,MADFe,CAFwC,CAApBW;EAKnB;IAAAC;IAAAC;EAAA,6BACD;IACFb,KAAC;MAEHf,IAAqB,YAFlB;MAGD6B;IAHC,CADC;IAMAC,8BANA;IAOEC,sBAAoB,qBAAa;EAPnC,EADC,EAUAC;WACD;EADC,EAVA,UAcDC,SAAU;IACVjC;EADU,EAdT,sBAiBc;IACb0B;EADa,EAjBd,EAoBCQ,eAAG,UAAU;IACbJ;sBAAAA;;IAAAA;EADa,CAAV,CApBJ;;uBA2BC;YACcK;;UAClBF;MAEFC,KAAqBE,cAFnB;MASAN;QACEC,OAAGM,EAAS,sDAAZ,KAAY,IAAZ,GAAYF,EAAZ,GAAY,EADd;QAEED,WAAc,mDAAdA,KAAc,IAAdA,GAAcpB,EAAdoB,GAAc;MAFhB;IATA;IAeF,qBAAc;gBAAA;MAEVI;IAFU,GAEoCV;MAC9CW;IAD8C,eAQ9C;MACHL,aADG;MAGGJ;QACLQ,GAAe,oBADV;QAELC,IAAe,oBAFV;QAGLC;MAHK,GAIR,oDAJQ;IAHH,CAR8C,EAFpC,CAAd","names":["useFloatingUI","defineProperty","arrow","Object","useAriaAnnounce","hasOwnProperty","isDesktop","useTooltip","props","value","key","enumerable","configurable","writable","b","useRef","useControlled","controlled","default","name","__getOwnPropSymbols","state","prop","__defNormalProp","a","flip","leaveDelay","open","onOpenChange","placement","disabled","disableHoverListener","disableFocusListener","shift","setOpen","offset","floating","element","arrowRef","update","limiter","_d","delay","Math","handleClose","reference","x","y","strategy","middlewareData","context","open1","role","ancestorScroll","getReferenceProps","getFloatingProps","close","style","left","useFocus","arrowProps","ref","_b","handleArrowRef","userProps","getTooltipProps","getTriggerProps","position"],"sources":["/Users/forgi/Development/code/phase-5/lux_nyc_final_project/lux_nyc_react_frontend/node_modules/@jpmorganchase/uitk-core/dist-es/packages/core/src/src/tooltip/useTooltip.ts"],"sourcesContent":["import { useFloatingUI, UseFloatingUIProps } from \"../popper\";\nimport {\n  arrow,\n  flip,\n  limitShift,\n  offset,\n  safePolygon,\n  shift,\n  useDismiss,\n  useFocus,\n  useHover,\n  useInteractions,\n  useRole,\n} from \"@floating-ui/react-dom-interactions\";\nimport { useAriaAnnounce } from \"./useAriaAnnounce\";\nimport { margin, useControlled } from \"../utils\";\nimport {\n  ComponentPropsWithoutRef,\n  ComponentPropsWithRef,\n  JSXElementConstructor,\n  useCallback,\n  useRef,\n} from \"react\";\nimport { TooltipProps } from \"./Tooltip\";\nimport { isDesktop } from \"../window\";\n\nexport interface UseTooltipProps\n  extends Partial<\n    Pick<UseFloatingUIProps, \"onOpenChange\" | \"open\" | \"placement\">\n  > {\n  disabled?: boolean;\n  /**\n   * Do not respond to focus events.\n   */\n  disableFocusListener?: boolean;\n  /**\n   * Do not respond to hover events.\n   */\n  disableHoverListener?: boolean;\n  /**\n   * The number of milliseconds to wait before showing the tooltip.\n   * This prop won't impact the enter touch delay (`enterTouchDelay`).\n   */\n  enterDelay?: number;\n  /**\n   * The number of milliseconds to wait before hiding the tooltip.\n   * This prop won't impact the leave touch delay (`leaveTouchDelay`).\n   */\n  leaveDelay?: number;\n}\n\nexport function useTooltip(props?: UseTooltipProps) {\n  const {\n    enterDelay = 100,\n    leaveDelay = 0,\n    open: openProp,\n    onOpenChange,\n    placement: placementProp = \"right\",\n    disabled,\n    disableHoverListener,\n    disableFocusListener,\n  } = props || {};\n\n  const arrowRef = useRef<HTMLDivElement | null>(null);\n\n  const [open, setOpen] = useControlled({\n    controlled: openProp,\n    default: false,\n    name: \"Tooltip\",\n    state: \"open\",\n  });\n  const handleOpenChange = (open: boolean) => {\n    setOpen(open);\n    onOpenChange?.(open);\n  };\n\n  const middleware = isDesktop\n    ? [margin(8), arrow({ element: arrowRef })]\n    : [\n        offset(8),\n        flip(),\n        shift({\n          limiter: limitShift({\n            offset: () =>\n              Math.max(\n                arrowRef.current?.offsetWidth ?? 0,\n                arrowRef.current?.offsetHeight ?? 0\n              ),\n          }),\n        }),\n        arrow({ element: arrowRef }),\n      ];\n  const {\n    floating,\n    reference,\n    x,\n    y,\n    strategy,\n    update,\n    middlewareData,\n    placement,\n    context,\n  } = useFloatingUI({\n    open,\n    onOpenChange: handleOpenChange,\n    placement: placementProp,\n    middleware,\n  });\n\n  const handleArrowRef = useCallback(\n    (node: HTMLDivElement) => {\n      arrowRef.current = node;\n      update();\n    },\n    [update]\n  );\n\n  const { getReferenceProps, getFloatingProps } = useInteractions([\n    useHover(context, {\n      delay: {\n        open: enterDelay,\n        close: leaveDelay,\n      },\n      enabled: !disableHoverListener,\n      handleClose: isDesktop ? null : safePolygon(),\n    }),\n    useFocus(context, { enabled: !disableFocusListener }),\n    useRole(context, { role: \"tooltip\" }),\n    useDismiss(context, { ancestorScroll: true }),\n    useAriaAnnounce(context, {\n      delay: {\n        open: enterDelay,\n        close: leaveDelay,\n      },\n    }),\n  ]);\n\n  const getTooltipProps = (userProps?: TooltipProps): TooltipProps => {\n    const arrowProps = {\n      ref: handleArrowRef,\n      style: {\n        left: middlewareData.arrow?.x ?? \"\",\n        top: middlewareData.arrow?.y ?? \"\",\n      },\n    };\n\n    return {\n      arrowProps,\n      open,\n      ...getFloatingProps({\n        // @ts-ignore\n        \"data-placement\": placement,\n        ...userProps,\n        ref: floating,\n        style: {\n          top: y ?? \"\",\n          left: x ?? \"\",\n          position: strategy,\n          ...(userProps?.style || {}),\n        },\n      }),\n    } as TooltipProps;\n  };\n\n  const getTriggerProps = <\n    Element extends\n      | keyof JSX.IntrinsicElements\n      | JSXElementConstructor<any> = \"div\"\n  >(\n    userProps?: ComponentPropsWithoutRef<Element>\n  ) => {\n    return getReferenceProps({\n      ...userProps,\n      ref: reference,\n    }) as ComponentPropsWithRef<Element>;\n  };\n\n  if (disabled) {\n    return {\n      getTooltipProps: (args?: TooltipProps) => args,\n      getTriggerProps: <\n        Element extends\n          | keyof JSX.IntrinsicElements\n          | JSXElementConstructor<any> = \"div\"\n      >(\n        args?: ComponentPropsWithRef<Element>\n      ) => args as ComponentPropsWithRef<Element>,\n    };\n  }\n\n  return {\n    getTooltipProps,\n    getTriggerProps,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}