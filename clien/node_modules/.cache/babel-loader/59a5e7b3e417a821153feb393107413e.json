{"ast":null,"code":"import { jsx } from 'react/jsx-runtime';\nimport cx from 'classnames';\nimport React, { createContext, useContext, useState } from 'react';\nimport '../aria-announcer/AriaAnnouncerContext.js';\nimport 'warning';\nimport { AriaAnnouncerProvider } from '../aria-announcer/AriaAnnouncerProvider.js';\nimport { DEFAULT_BREAKPOINTS } from '../breakpoints/Breakpoints.js';\nimport { getTheme, DEFAULT_THEME } from '../theme/Theme.js';\nimport { useIsomorphicLayoutEffect } from '../utils/useIsomorphicLayoutEffect.js';\nimport { ViewportProvider } from '../viewport/ViewportProvider.js';\nconst DEFAULT_DENSITY = \"medium\";\nconst DEFAULT_THEME_NAME = \"light\";\nconst ToolkitContext = /* @__PURE__ */createContext({\n  density: void 0,\n  themes: [],\n  breakpoints: {}\n});\n\nconst createThemedChildren = (children, themeNames, density, applyClassesToChild) => {\n  var _a;\n\n  if (applyClassesToChild) {\n    if ( /* @__PURE__ */React.isValidElement(children)) {\n      return /* @__PURE__ */React.cloneElement(children, {\n        className: cx((_a = children.props) == null ? void 0 : _a.className, ...themeNames.map(themeName => `uitk-${themeName}`), `uitk-density-${density}`)\n      });\n    } else {\n      console.warn(`\nToolkitProvider can only apply CSS classes for theming to a single nested child element of the ToolkitProvider.\n        Either wrap elements with a single container or consider removing the applyClassesToChild prop, in which case a\n        uitk-theme element will wrap your child elements`);\n      return children;\n    }\n  } else {\n    return /* @__PURE__ */jsx(\"uitk-theme\", {\n      class: cx(...themeNames.map(themeName => `uitk-${themeName}`), `uitk-density-${density}`),\n      children\n    });\n  }\n};\n\nconst getThemeName = (theme1, inheritedThemes) => {\n  if (theme1) {\n    return theme1;\n  } else if (Array.isArray(inheritedThemes) && inheritedThemes.length > 0) {\n    return inheritedThemes.map(theme => theme.name);\n  } else {\n    return DEFAULT_THEME_NAME;\n  }\n};\n\nconst ToolkitProvider = _ref => {\n  let {\n    applyClassesToChild = false,\n    children,\n    density: densityProp,\n    theme: themesProp,\n    breakpoints: breakpointsProp\n  } = _ref;\n\n  var _a;\n\n  const {\n    themes: inheritedThemes,\n    density: inheritedDensity\n  } = useContext(ToolkitContext);\n  const isRoot = inheritedThemes === void 0 || Array.isArray(inheritedThemes) && inheritedThemes.length === 0;\n  const density = (_a = densityProp != null ? densityProp : inheritedDensity) != null ? _a : DEFAULT_DENSITY;\n  const themeName = getThemeName(themesProp, inheritedThemes);\n  const themes = getTheme(themeName);\n  const breakpoints = breakpointsProp != null ? breakpointsProp : DEFAULT_BREAKPOINTS;\n  const themedChildren = createThemedChildren(children, themes.map(theme => theme.name), density, applyClassesToChild);\n  const toolkitProvider = /* @__PURE__ */jsx(ToolkitContext.Provider, {\n    value: {\n      density,\n      themes,\n      breakpoints\n    },\n    children: /* @__PURE__ */jsx(ViewportProvider, {\n      children: themedChildren\n    })\n  });\n\n  if (isRoot) {\n    return /* @__PURE__ */jsx(AriaAnnouncerProvider, {\n      children: toolkitProvider\n    });\n  } else {\n    return toolkitProvider;\n  }\n};\n\nconst useTheme = () => {\n  const {\n    themes = [DEFAULT_THEME]\n  } = useContext(ToolkitContext);\n  return themes;\n};\n\nfunction useDensity(density) {\n  const {\n    density: densityFromContext\n  } = useContext(ToolkitContext);\n  return density || densityFromContext || DEFAULT_DENSITY;\n}\n\nconst useBreakpoints = () => {\n  const {\n    breakpoints\n  } = useContext(ToolkitContext);\n  return breakpoints;\n};\n\nconst useCharacteristic = function (characteristicName, variant) {\n  let ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  const [theme] = useTheme();\n  const [value1, setValue] = useState(null);\n  const target = (ref == null ? void 0 : ref.current) !== void 0 ? ref.current : ref;\n  useIsomorphicLayoutEffect(() => {\n    if (theme) {\n      const value = theme.getCharacteristicValue(characteristicName, variant, target || void 0);\n      setValue(value);\n    }\n  }, [characteristicName, target, theme, variant]);\n  return value1;\n};\n\nexport { DEFAULT_DENSITY, ToolkitContext, ToolkitProvider, useBreakpoints, useCharacteristic, useDensity, useTheme };","map":{"version":3,"mappings":";;;;;;;;;;AAyBaA,qBAAe,GAAG,QAAlBA;AAUb,MAAMC,kBAAkB,GAAG,OAA3B;AAcaC,oBAAc,kBAAGC,aAAmC;EAC/DC,SAAO,KAAW,CAD6C;EAE/DC,QAAM,EAFyD;EAG/DC,aAAW;AAHoD,EAApDJ;;AAMb,MAAMK,oBAAoB,GAAG,CAC3BC,QAD2B,EAE3BC,UAF2B,EAG3BL,OAH2B,EAI3BM,mBAJ2B,KAKxB;EACH;;EACE;IACE,yCAAyBF,QAAzB,GAAyB;4BACVG,KAC2D,aAD3D,CAC2DH,QAD3D,EAC2D;QACtEA,iBAASI,GAAKJ,QAAW,MAAzBA,KAAyB,IAAzBA,GAAyB,KACXK,CADdL,GACiBM,YADjBN,EACkC,GAAKC,UAAEM,CAASF,GAAX,CAAaE,gCAAb,CADvCP,EACoD,yBADpDA;MADsE,CAD3D;IAMd,CAPD,MAOC;aACI;;;AAI6C;MAElD;IACD;GAhBD,MAiBK;IACL,wCACa;MACTQ,aAAOC,UACFR,IADEQ,CACQF,SAAVN,IAAyB,QAAMM,SAAOA,EADpCE,CAAPD,EACsD,yBADtDA,CADS;MAE6CR;IAF7C,CADbU;;AAUD,CAnCH;;MAoCEC;EAuBF,IAAMA,MAAN,EAAMA;IAIJ;EACE,CALJ,MAKI,kBAAaC,eAAb,KAAaA,0BAAb,EAAa;IACd,OAAMA,eAAUC,IAAV,CAAkBD,cAAgB,KAAlC,CAAN;GADC,MAEOA;IAAyC,OAAEnB,kBAAF;;AAEhD;;AACD;EAAA;IAAAS;IAAAF;IAAAJ;IAAAkB;IAAAhB;EAAA;;EACD;;EAEF,MAAaiB;IAAAA;IACXb;EADWa,IAEHC,UACRpB,gBAHF;EAOE,YAAc,kBAAiB,UAAS,CAA1B,IAA4BqB,KAAgB,QAAhBA,CAAgBL,eAAhBK,KAC7BvB,eAAgB,OAAhBA,KAAgB,CAD7B;EAGA,gBACEkB,qBAAoBM,IAApBN,GAA6BO,WAA7BP,GACOC,gBADPD,KAC8B,IAD9BA,GACkDN,EADlDM,GACkDpB,eAFpD;QAGMI,SAAO,GAAGuB,YAAW,aAAoBP,eAApB;QACrBL,iBAAwB;EAC9B,iBAAwBa,kBAAkB,IAAE,IAApBA,GAAoBC,eAApBD,GAAoBE,mBAA5C;EACA,oBAAiB,GAAkBvB,qCAAuB,CAACM,GAAxB,CAAwBS,mBAAxB,GAAwBlB,OAAxB,EAAwBM,mBAAxB,CAAnC;EAEA,qBAAoB,kBAAuBQ,kBAEzCb,SAFyC,EAE7BiB;IAAoBS,KAChC3B;MAIFA,OAJEA;MAKyB2B,MALzB3B;;IAAAA,CADYkB;YAMuChB,iBAAWY;MAAEV;IAAF;EANlDc,CAF6B,CAA3C;;EASyD;IAC7B,sBAC1BJ;MAEFV,QAAU,EAAEwB;IAFV,EAD0B;GAD6B;WAKiBA;;AAExE,CArCD;;AAsCA;EACD;IAAA3B,UAEK4B,aAFL;EAAA,IAGMT,UAAQ,CAAGtB,cAAH,CAHd;SAG+BG;AAAC,CAJ/B;;AAKD,oBAAcD,OAAd,EAAc;EACd;IAAAA;EAAA;EAEF;;;AAGO,oBAAmB;QAClB;IAAAE;EAAA,IAA6BkB;EACnC;AACD,CAHM;;AAKA,MAAMU,iBAAiB,GAAM;EAAA;QAC5B,kBAAe;EACrB,2BAAmBC,cAAnB;EACA;EAGmDC;IAC9C,WAAuB;MAKc;MAC1CC,QAAY,OAAZ;IACM;EACN,CATmD,EASnD,CAKAD,kBALA,EAMEE,MANF,EAOIhB,KAPJ,UATmD;SAuBhDiB;CA7BE","names":["DEFAULT_DENSITY","DEFAULT_THEME_NAME","ToolkitContext","createContext","density","themes","breakpoints","createThemedChildren","children","themeNames","applyClassesToChild","React","props","map","_a","themeName","class","cx","_jsx","getThemeName","inheritedThemes","isArray","theme","ToolkitProvider","useContext","inheritedDensity","undefined","densityProp","getTheme","breakpointsProp","DEFAULT_BREAKPOINTS","value","toolkitProvider","DEFAULT_THEME","useBreakpoints","useState","useIsomorphicLayoutEffect","setValue","target","value1"],"sources":["/Users/forgi/Development/code/phase-5/lux_nyc_final_project/lux_nyc_react_frontend/node_modules/@jpmorganchase/uitk-core/dist-es/packages/core/src/src/toolkit-provider/ToolkitProvider.tsx"],"sourcesContent":["import cx from \"classnames\";\nimport React, {\n  createContext,\n  DetailedHTMLProps,\n  DOMAttributes,\n  FC,\n  HTMLAttributes,\n  ReactElement,\n  ReactNode,\n  RefObject,\n  useContext,\n  useState,\n} from \"react\";\nimport { AriaAnnouncerProvider } from \"../aria-announcer\";\nimport { Breakpoints, DEFAULT_BREAKPOINTS } from \"../breakpoints\";\nimport {\n  characteristic,\n  DEFAULT_THEME,\n  Density,\n  getTheme,\n  Theme,\n} from \"../theme\";\nimport { useIsomorphicLayoutEffect } from \"../utils/useIsomorphicLayoutEffect\";\nimport { ViewportProvider } from \"../viewport\";\n\nexport const DEFAULT_DENSITY = \"medium\";\n\n// TODDO this forces anyone using ToolkitContext directly to deal with themes (as opposed to theme)\n// needs more thought\nexport interface ToolkitContextProps {\n  density?: Density;\n  themes?: Theme[];\n  breakpoints: Breakpoints;\n}\n\nconst DEFAULT_THEME_NAME = \"light\";\n\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  namespace JSX {\n    interface IntrinsicElements {\n      \"uitk-theme\": DetailedHTMLProps<\n        DOMAttributes<HTMLDivElement> & { class: string },\n        HTMLDivElement\n      >;\n    }\n  }\n}\n\nexport const ToolkitContext = createContext<ToolkitContextProps>({\n  density: undefined,\n  themes: [],\n  breakpoints: {} as Breakpoints,\n});\n\nconst createThemedChildren = (\n  children: ReactNode,\n  themeNames: string[],\n  density: Density,\n  applyClassesToChild: boolean\n) => {\n  if (applyClassesToChild) {\n    if (React.isValidElement<HTMLAttributes<HTMLElement>>(children)) {\n      return React.cloneElement(children, {\n        className: cx(\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n          children.props?.className,\n          ...themeNames.map((themeName) => `uitk-${themeName}`),\n          `uitk-density-${density}`\n        ),\n      });\n    } else {\n      console.warn(\n        `\\nToolkitProvider can only apply CSS classes for theming to a single nested child element of the ToolkitProvider.\n        Either wrap elements with a single container or consider removing the applyClassesToChild prop, in which case a\n        uitk-theme element will wrap your child elements`\n      );\n      return children;\n    }\n  } else {\n    return (\n      <uitk-theme\n        class={cx(\n          ...themeNames.map((themeName) => `uitk-${themeName}`),\n          `uitk-density-${density}`\n        )}\n      >\n        {children}\n      </uitk-theme>\n    );\n  }\n};\n\ninterface ToolkitProviderThatAppliesClassesToChild {\n  children: ReactElement;\n  density?: Density;\n  theme?: ThemeNameType;\n  applyClassesToChild?: true;\n  breakpoints?: Breakpoints;\n}\n\ntype ThemeNameType = string | Array<string>;\ninterface ToolkitProviderThatInjectsThemeElement {\n  children: ReactNode;\n  density?: Density;\n  theme?: ThemeNameType;\n  applyClassesToChild?: false;\n  breakpoints?: Breakpoints;\n}\n\ntype toolkitProvider =\n  | ToolkitProviderThatAppliesClassesToChild\n  | ToolkitProviderThatInjectsThemeElement;\n\nconst getThemeName = (\n  theme: ThemeNameType | undefined,\n  inheritedThemes: Theme[] | undefined\n): ThemeNameType => {\n  if (theme) {\n    return theme;\n  } else if (Array.isArray(inheritedThemes) && inheritedThemes.length > 0) {\n    return inheritedThemes.map((theme) => theme.name);\n  } else {\n    return DEFAULT_THEME_NAME;\n  }\n};\n\nexport const ToolkitProvider: FC<toolkitProvider> = ({\n  applyClassesToChild = false,\n  children,\n  density: densityProp,\n  theme: themesProp,\n  breakpoints: breakpointsProp,\n}) => {\n  const { themes: inheritedThemes, density: inheritedDensity } =\n    useContext(ToolkitContext);\n\n  const isRoot =\n    inheritedThemes === undefined ||\n    (Array.isArray(inheritedThemes) && inheritedThemes.length === 0);\n  const density = densityProp ?? inheritedDensity ?? DEFAULT_DENSITY;\n  const themeName = getThemeName(themesProp, inheritedThemes);\n  const themes: Theme[] = getTheme(themeName);\n  const breakpoints = breakpointsProp ?? DEFAULT_BREAKPOINTS;\n\n  const themedChildren = createThemedChildren(\n    children,\n    themes.map((theme) => theme.name),\n    density,\n    applyClassesToChild\n  );\n\n  const toolkitProvider = (\n    <ToolkitContext.Provider value={{ density, themes, breakpoints }}>\n      <ViewportProvider>{themedChildren}</ViewportProvider>\n    </ToolkitContext.Provider>\n  );\n\n  if (isRoot) {\n    return <AriaAnnouncerProvider>{toolkitProvider}</AriaAnnouncerProvider>;\n  } else {\n    return toolkitProvider;\n  }\n};\n\nexport const useTheme = (): Theme[] => {\n  const { themes = [DEFAULT_THEME] } = useContext(ToolkitContext);\n  return themes;\n};\n\n/**\n * `useDensity` merges density value from 'DensityContext` with the one from component's props.\n */\nexport function useDensity(density?: Density): Density {\n  const { density: densityFromContext } = useContext(ToolkitContext);\n  return density || densityFromContext || DEFAULT_DENSITY;\n}\n\nexport const useBreakpoints = () => {\n  const { breakpoints } = useContext(ToolkitContext);\n  return breakpoints;\n};\n\ntype HTMLElementRef = RefObject<HTMLElement>;\n// We might want to cache values in a local WeakMap ?\nexport const useCharacteristic = (\n  characteristicName: characteristic,\n  variant: string,\n  ref: HTMLElementRef | HTMLElement | null = null\n): string | null => {\n  // TODO what do we do with multiple themes\n  const [theme] = useTheme();\n  const [value, setValue] = useState<string | null>(null);\n  const target =\n    (ref as HTMLElementRef)?.current !== undefined\n      ? (ref as HTMLElementRef).current\n      : (ref as HTMLElement);\n\n  useIsomorphicLayoutEffect(() => {\n    if (theme) {\n      const value = theme.getCharacteristicValue(\n        characteristicName,\n        variant,\n        target || undefined\n      );\n      setValue(value);\n    }\n  }, [characteristicName, target, theme, variant]);\n\n  return value;\n};\n"]},"metadata":{},"sourceType":"module"}